// Étape 1.1.1 - Modèle de données Utilisateurs, Organisations & Rôles
// Référence: Cahier des charges - Section 2.4 Matrice des Permissions, 13.1 Architecture multi-tenant

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============= 1. Enum Role =============
enum Role {
  ADMIN    // Administrateur système - accès complet
  DIRECTOR // Gestionnaire Philanthropique (Directeur) - lecture seule sur campagnes
  MANAGER  // Gestionnaire de Campagnes - accès complet aux campagnes
}

// ============= Étape 2.1.1 - Enums Formulaires de Don =============
enum FormStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum SubmissionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum PaymentStatus {
  CREATED
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELLED
  EXPIRED
}

// ============= Étape 3.1.1 - Enums Marketing =============
enum EmailCampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  CANCELED
}

enum AudienceType {
  STATIC
  DYNAMIC
}

// ============= 2. Modèle Organization =============
model Organization {
  id          String   @id @default(cuid())
  name        String   // Nom de l'organisation (ex: "Croix-Rouge Québec")
  slug        String   @unique // URL-friendly identifier (ex: "croix-rouge-quebec")

  // Informations de branding
  logo        String?  // URL du logo de l'organisation
  website     String?  // Site web officiel
  description String?  @db.Text // Description de la mission

  // Coordonnées
  email       String?  // Email de contact principal
  phone       String?  // Téléphone principal
  address     String?  // Adresse physique complète
  city        String?
  province    String?
  postalCode  String?
  country     String   @default("CA") // Code pays ISO (CA, US, FR, etc.)

  // Paramètres système
  timezone    String   @default("America/Toronto") // Fuseau horaire
  currency    String   @default("CAD") // Devise par défaut (CAD, USD, EUR)
  language    String   @default("fr") // Langue par défaut (fr, en)

  // Statut
  isActive    Boolean  @default(true) // Organisation active ou suspendue

  // Relations
  users             User[]
  donators          Donator[]
  donationForms     DonationForm[]
  formSubmissions   DonationFormSubmission[]
  paymentIntents    PaymentIntent[]
  subscriptions     Subscription[]
  donations         Donation[]
  emailCampaigns    EmailCampaign[]
  emailTemplates    EmailTemplate[]
  audiences         Audience[]
  workflows         Workflow[]
  segmentSuggestions SegmentSuggestion[]
  p2pCampaigns       P2PCampaign[]

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([isActive])
  @@map("organizations")
}

// ============= 3. Modèle User =============
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?

  // Informations personnelles
  firstName     String?
  lastName      String?
  phone         String?
  avatar        String?   // URL de l'avatar

  // Authentification
  password      String?   // Hash du mot de passe (si auth locale)

  // Organisation et rôle
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  role           Role      @default(MANAGER)

  // Statut
  isActive      Boolean   @default(true)
  lastLoginAt   DateTime?

  // Relations existantes (à conserver)
  accounts        Account[]
  sessions        Session[]
  dashboardLayout DashboardLayout?
  reports         Report[]
  reportSchedules ReportSchedule[]

  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([email])
  @@index([organizationId])
  @@index([role])
  @@map("users")
}

// Modèles requis pour les relations User.accounts et User.sessions
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

// ============= Étape 4.1.1 - Dashboard Principal =============
model DashboardLayout {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  layout    Json     // Position et taille des widgets (react-grid-layout)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("dashboard_layouts")
}

// ============= Étape 4.2.1 - Générateur de Rapports =============
model Report {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  config      Json     // métriques, dimensions, période
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@map("reports")
}

// ============= Étape 4.2.3 - Planification des rapports =============
model ReportSchedule {
  id                  String   @id @default(cuid())
  name                String   // Libellé de la planification
  userId              String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reportId            String?  // Rapport personnalisé (optionnel)
  predefinedReportType String?  // Type de rapport prédéfini (optionnel)
  frequency           String   // daily | weekly | monthly
  recipients          Json     // ["email1@example.com", "email2@example.com"]
  nextRunAt           DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@index([nextRunAt])
  @@map("report_schedules")
}

// ============= 4. Modèle Donator =============
model Donator {
  id            String   @id @default(cuid())

  // Informations personnelles
  email         String   // Email principal du donateur
  firstName     String?
  lastName      String?
  phone         String?

  // Adresse
  address       String?
  city          String?
  province      String?
  postalCode    String?
  country       String?

  // Informations professionnelles
  profession    String?
  employer      String?
  sector        String?  // Secteur d'activité

  // Préférences de communication
  preferredChannel String? // email, phone, sms, mail
  preferredLanguage String @default("fr") // fr, en
  communicationFrequency String? // weekly, monthly, quarterly

  // Intérêts et causes
  interests     String[] // Array de causes d'intérêt

  // Champs personnalisés (JSON pour flexibilité)
  customFields  Json?    // Champs additionnels spécifiques à l'organisation

  // Consentements RGPD/PIPEDA
  consentEmail  Boolean  @default(false)
  consentPhone  Boolean  @default(false)
  consentSMS    Boolean  @default(false)
  consentMail   Boolean  @default(false)
  consentDate   DateTime?

  // Désinscription email marketing (Étape 3.1.1)
  unsubscribedAt DateTime?

  // Segmentation automatique (sera calculé par l'IA)
  segment       String?  // VIP, Active, Inactive, New, etc.
  score         Int      @default(0) // Score de propension au don (0-100)
  
  // Prédiction de churn (Étape 5.3.1)
  churnProbability Float? // Probabilité de churn (0-1)

  // Métriques de dons (seront calculées)
  totalDonations Decimal @default(0) @db.Decimal(10, 2)
  donationCount  Int     @default(0)
  averageDonation Decimal @default(0) @db.Decimal(10, 2)
  lastDonationDate DateTime?
  firstDonationDate DateTime?

  // Statut
  isActive      Boolean  @default(true)

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Relations formulaires de don
  formSubmissions DonationFormSubmission[]
  subscriptions   Subscription[]
  donations       Donation[]

  // Relations marketing (Étape 3.1.1)
  emailCampaigns EmailCampaign[]
  audiences      Audience[]

  // Relations commentaires (Étape 5.2.2)
  comments       Comment[]
  
  // Relations P2P (Étape 6.1.1)
  // Note: Les participants P2P peuvent être des donateurs existants ou de nouveaux participants
  // La relation se fait via l'email dans P2PParticipant

  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([email, organizationId]) // Un email unique par organisation
  @@index([email])
  @@index([organizationId])
  @@index([segment])
  @@index([lastDonationDate])
  @@index([churnProbability])
  @@map("donators")
}

// ============= 5. Modèle Donation (Phase 1 + liens formulaires) =============
model Donation {
  id     String @id @default(cuid())

  // Donateur
  donatorId String
  donator   Donator  @relation(fields: [donatorId], references: [id], onDelete: Cascade)

  // Montant
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("CAD")

  // Statut
  status String @default("completed") // pending, completed, failed, refunded

  // Lien vers le formulaire (si don via formulaire)
  formId      String?
  form        DonationForm? @relation(fields: [formId], references: [id], onDelete: SetNull)

  // Lien vers la soumission (si don via formulaire)
  submissionId String?  @unique
  submission   DonationFormSubmission? @relation(fields: [submissionId], references: [id], onDelete: SetNull)

  // Lien vers l'abonnement (si don récurrent)
  subscriptionId String?
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Timestamps
  donatedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([donatorId])
  @@index([organizationId])
  @@index([formId])
  @@index([subscriptionId])
  @@index([donatedAt])
  @@map("donations")
}

// ============= Étape 2.1.1 - DonationForm =============
model DonationForm {
  id          String   @id @default(cuid())

  // Informations de base
  title       String
  description String?  @db.Text
  slug        String   @unique

  // Configuration des montants
  amountType       String   @default("flexible") // flexible, fixed
  suggestedAmounts Json     // Array de montants suggérés [25, 50, 100, 250, 500]
  minAmount        Decimal? @db.Decimal(10, 2)
  maxAmount        Decimal? @db.Decimal(10, 2)
  currency         String   @default("CAD")

  // Dons récurrents
  allowRecurring Boolean @default(false)
  frequencies    Json?   // Array de fréquences ["monthly", "quarterly", "yearly"]

  // Champs du formulaire
  requiredFields Json // Array de champs requis ["email", "firstName", "lastName"]
  optionalFields Json // Array de champs optionnels activés ["phone", "address", "message"]
  customFields   Json? // Array de champs personnalisés avec config

  // Design et branding
  primaryColor String  @default("#3B82F6")
  logo         String?
  coverImage   String?
  font         String  @default("Inter")
  buttonStyle  String  @default("gradient") // solid, outline, gradient

  // Messages
  welcomeMessage  String? @db.Text
  thankYouMessage String? @db.Text
  emailTemplate   String? @db.Text
  redirectUrl     String?

  // Paramètres avancés
  enableConsents Boolean @default(true)
  consentText    String? @db.Text
  enableCaptcha  Boolean @default(false)
  maxDonations   Int?
  startDate      DateTime?
  endDate        DateTime?
  goalAmount     Decimal? @db.Decimal(10, 2)

  // Statistiques (calculées)
  totalCollected   Decimal @default(0) @db.Decimal(10, 2)
  donationCount    Int     @default(0)
  viewCount        Int     @default(0)
  submissionCount  Int     @default(0)
  conversionRate   Decimal @default(0) @db.Decimal(5, 2)

  // Statut
  status   FormStatus @default(DRAFT)
  isActive Boolean    @default(true)

  // Relations
  submissions   DonationFormSubmission[]
  subscriptions Subscription[]
  donations      Donation[]

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Timestamps
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([organizationId])
  @@index([status])
  @@map("donation_forms")
}

// ============= Étape 2.1.1 - DonationFormSubmission =============
model DonationFormSubmission {
  id     String @id @default(cuid())

  // Formulaire lié
  formId String
  form   DonationForm @relation(fields: [formId], references: [id], onDelete: Cascade)

  // Donateur
  donatorId String?
  donator   Donator?  @relation(fields: [donatorId], references: [id], onDelete: SetNull)

  // Montant
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("CAD")

  // Récurrence
  isRecurring Boolean @default(false)
  frequency   String? // monthly, quarterly, yearly

  // Données du formulaire (JSON)
  formData Json

  // Informations du donateur (dénormalisées)
  email      String
  firstName  String?
  lastName   String?
  phone      String?
  address    String?
  city       String?
  province   String?
  postalCode String?
  country    String?

  // Message et dédicace
  message     String?  @db.Text
  dedication  String?
  isAnonymous Boolean  @default(false)

  // Consentements
  consentEmail Boolean @default(false)
  consentPhone Boolean @default(false)
  consentSMS   Boolean @default(false)
  consentMail  Boolean @default(false)

  // Statut
  status SubmissionStatus @default(PENDING)

  // Relations
  paymentIntent PaymentIntent?
  donation      Donation?
  subscription  Subscription?

  // Métadonnées
  ipAddress String?
  userAgent String?
  referrer  String?

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Timestamps
  submittedAt DateTime  @default(now())
  completedAt DateTime?

  @@index([formId])
  @@index([donatorId])
  @@index([organizationId])
  @@index([status])
  @@index([submittedAt])
  @@map("donation_form_submissions")
}

// ============= Étape 2.1.1 - PaymentIntent =============
model PaymentIntent {
  id     String @id @default(cuid())

  // Soumission liée
  submissionId String  @unique
  submission   DonationFormSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // Passerelle
  gateway    String
  externalId String

  // Montant
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("CAD")

  // Statut
  status PaymentStatus @default(CREATED)

  // Méthode de paiement
  paymentMethod String?
  last4         String?
  brand         String?

  // Erreurs
  errorCode    String?
  errorMessage String? @db.Text

  // Métadonnées passerelle
  metadata Json?

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  succeededAt DateTime?
  failedAt    DateTime?

  @@index([submissionId])
  @@index([externalId])
  @@index([organizationId])
  @@index([status])
  @@map("payment_intents")
}

// ============= Étape 2.1.1 - Subscription =============
model Subscription {
  id     String @id @default(cuid())

  // Donateur
  donatorId String
  donator   Donator @relation(fields: [donatorId], references: [id], onDelete: Cascade)

  // Formulaire
  formId String
  form   DonationForm @relation(fields: [formId], references: [id], onDelete: Cascade)

  // Soumission initiale
  submissionId String  @unique
  submission   DonationFormSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  // Configuration
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("CAD")
  frequency String // monthly, quarterly, yearly

  // Passerelle
  gateway        String
  subscriptionId String

  // Statut
  status SubscriptionStatus @default(ACTIVE)

  // Dates
  startDate          DateTime  @default(now())
  nextPaymentDate    DateTime
  endDate            DateTime?
  cancelledAt        DateTime?
  cancellationReason String?

  // Relations
  donations Donation[]

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([donatorId])
  @@index([formId])
  @@index([organizationId])
  @@index([status])
  @@index([nextPaymentDate])
  @@map("subscriptions")
}

// ============= Étape 3.1.1 - EmailTemplate =============
model EmailTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text

  // Contenu (éditeur drag & drop)
  content   Json     // Structure pour l'éditeur
  html      String   @db.Text // HTML généré à partir du content
  thumbnail String?  // URL de l'image d'aperçu

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Relations
  campaigns EmailCampaign[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@map("email_templates")
}

// ============= Étape 3.1.1 - Audience =============
model Audience {
  id          String       @id @default(cuid())
  name        String
  description String?      @db.Text
  type        AudienceType // STATIC = liste fixe, DYNAMIC = segments par règles

  // STATIC: liste de donateurs via relation; DYNAMIC: règles de segmentation
  rules Json? // Règles pour segments dynamiques (ex: segment, lastDonationDate, etc.)
  // DYNAMIC: nombre de donateurs (mis à jour par "Rafraîchir" - Étape 3.2.2)
  cachedDonatorCount Int?

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // STATIC: donators liés; DYNAMIC: calculé à l'envoi via rules
  donators Donator[]

  // Relations
  campaigns EmailCampaign[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([type])
  @@map("audiences")
}

// ============= Étape 3.1.1 - EmailCampaign =============
model EmailCampaign {
  id        String   @id @default(cuid())
  name      String
  subject   String
  fromName  String
  fromEmail String

  // Statut
  status      EmailCampaignStatus @default(DRAFT)
  scheduledAt DateTime?
  sentAt      DateTime?

  // Template et audience
  templateId String
  template   EmailTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)
  audienceId String
  audience   Audience     @relation(fields: [audienceId], references: [id], onDelete: Restrict)

  // Stats (sent, delivered, opened, clicked, bounced, unsubscribed)
  stats Json?

  // Organisation (multi-tenant)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Destinataires (donateurs ayant reçu / ciblés par la campagne)
  donators Donator[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([templateId])
  @@index([audienceId])
  @@index([status])
  @@index([scheduledAt])
  @@map("email_campaigns")
}

// ============= Étape 3.3.2 - Workflow (Automatisation) =============
enum WorkflowStatus {
  DRAFT
  ACTIVE
}

model Workflow {
  id             String         @id @default(cuid())
  name           String
  organizationId String
  organization   Organization  @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  status         WorkflowStatus @default(DRAFT)

  // Graphe (nœuds et connexions au format React Flow / XYFlow)
  nodes Json? // Array de { id, type, position, data }
  edges Json? // Array de { id, source, target }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([status])
  @@map("workflows")
}

// ============= Étape 5.1.2 - Segmentation Intelligente =============
model SegmentSuggestion {
  id          String   @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  name        String   // Nom du segment suggéré (ex: "Donateurs à haut potentiel")
  description String   @db.Text // Description du segment
  criteria    Json     // Critères de segmentation (ex: {min_total_donated: 1000, min_score: 70})
  donorCount  Int      @default(0) // Nombre de donateurs correspondant aux critères
  
  // Métadonnées du clustering
  clusterId   String?  // ID du cluster (pour regrouper les suggestions similaires)
  confidence  Float?   // Score de confiance (0-1) de la suggestion
  
  // Statut
  isAccepted  Boolean  @default(false) // Si l'utilisateur a accepté et créé le segment
  acceptedAt  DateTime? // Date d'acceptation
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([organizationId])
  @@index([isAccepted])
  @@index([clusterId])
  @@map("segment_suggestions")
}

// ============= Étape 6.1.1 - Modèles P2P (Peer-to-Peer) =============
enum P2PCampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum P2PParticipantStatus {
  ACTIVE
  INACTIVE
  COMPLETED
}

// Campagne P2P principale
model P2PCampaign {
  id          String   @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  
  // Informations de base
  name        String
  description String?  @db.Text
  slug        String   @unique // URL-friendly identifier
  
  // Dates
  startDate   DateTime?
  endDate     DateTime?
  
  // Objectifs
  goalAmount  Decimal? @db.Decimal(10, 2)
  goalParticipants Int?
  
  // Statut
  status      P2PCampaignStatus @default(DRAFT)
  
  // Configuration
  allowTeams  Boolean  @default(true) // Permet la création d'équipes
  allowIndividualParticipants Boolean @default(true) // Permet les participants individuels
  minTeamSize Int?     // Taille minimale d'équipe
  maxTeamSize Int?     // Taille maximale d'équipe
  
  // Branding
  coverImage  String?  // URL de l'image de couverture
  logo        String?  // URL du logo
  primaryColor String?  // Couleur principale
  
  // Statistiques (calculées)
  totalRaised Decimal  @default(0) @db.Decimal(10, 2)
  participantCount Int @default(0)
  teamCount   Int     @default(0)
  donationCount Int   @default(0)
  
  // Relations
  participants P2PParticipant[]
  teams        P2PTeam[]
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([organizationId])
  @@index([status])
  @@index([slug])
  @@index([startDate])
  @@index([endDate])
  @@map("p2p_campaigns")
}

// Équipe de participants P2P
model P2PTeam {
  id          String   @id @default(cuid())
  campaignId  String
  campaign    P2PCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  // Informations de base
  name        String
  description String?  @db.Text
  slug        String   // URL-friendly identifier (unique par campagne)
  
  // Chef d'équipe (participant principal)
  teamLeaderId String?  // Référence au participant chef d'équipe
  
  // Objectifs
  goalAmount  Decimal? @db.Decimal(10, 2)
  
  // Statistiques (calculées)
  totalRaised Decimal  @default(0) @db.Decimal(10, 2)
  memberCount Int      @default(0)
  donationCount Int    @default(0)
  
  // Relations
  participants P2PParticipant[]
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([campaignId, slug])
  @@index([campaignId])
  @@index([teamLeaderId])
  @@map("p2p_teams")
}

// Participant P2P (individuel ou membre d'équipe)
model P2PParticipant {
  id          String   @id @default(cuid())
  campaignId  String
  campaign    P2PCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  
  // Équipe (optionnel - null si participant individuel)
  teamId      String?
  team        P2PTeam? @relation(fields: [teamId], references: [id], onDelete: SetNull)
  
  // Informations du participant
  firstName   String
  lastName   String
  email       String
  phone       String?
  
  // Page de collecte personnalisée
  slug        String   // URL-friendly identifier (unique par campagne)
  personalMessage String? @db.Text // Message personnalisé sur la page
  
  // Objectifs personnels
  goalAmount  Decimal? @db.Decimal(10, 2)
  
  // Statut
  status      P2PParticipantStatus @default(ACTIVE)
  
  // Statistiques (calculées)
  totalRaised Decimal  @default(0) @db.Decimal(10, 2)
  donationCount Int    @default(0)
  
  // Métadonnées
  profileImage String? // URL de la photo de profil
  customFields Json?   // Champs personnalisés additionnels
  
  // Relations avec les dons (via DonationFormSubmission ou Donation)
  // Note: Les dons sont liés via le champ campaignId dans Donation
  
  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([campaignId, slug])
  @@unique([campaignId, email]) // Un email unique par campagne
  @@index([campaignId])
  @@index([teamId])
  @@index([email])
  @@index([status])
  @@map("p2p_participants")
}

// ============= Étape 5.2.2 - Analyse de Sentiments =============
model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  sentiment String?  // "positive", "negative", "neutral"
  donatorId String
  donator   Donator  @relation(fields: [donatorId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([donatorId])
  @@index([sentiment])
  @@index([createdAt])
  @@map("comments")
}
